说明:这个回射服务器没有实现readline和writen&readn功能,因为我当初把他们实现在了聊天程序里了.
## 1. 僵尸进程
已经死亡的进程但在进程表中占有一个位置(slot).产生原因是子进程已经死亡,但父进程却没有等待(调用wait/waitpid)它
### 1-1. 检查是否存在僵尸进程
```
./server
./client
#################################
abc
123
^C
#################################

ps -ef | grep server
#----------------------------------------------------------------------------
# orris    13069  5904  0 20:27 pts/1    00:00:00 ./server
# orris    13071 13069  0 20:27 pts/1    00:00:00 [server] <defunct> # defunct就表示是僵尸进程
#----------------------------------------------------------------------------

```
### 1-2. 解决
1. (方法1)在服务器端的main函数里添加`signal(SIGCHLD,SIG_IGN);`就好了
2. (方法2)捕捉SIGCHLD信号,调用wait函数=>问题:只能等待一个子进程退出
    1. 实现
    ```
    void handle_sigchld(int sig)
    {   
        //调用wait函数子进程的状态
        wait(NULL);
        //wait进程仅仅等待第一个子进程的退出
    }
    signal(SIGCHLD,handle_sigchld);
    ```
    2. 问题:不能关闭所有子进程的问题重现<=多个信号SIGCHLD同时发送给服务端的时候,由于这些信号是不可靠信号,并且只能排队一个,所以就会丢失信号(当然信号的到来不一定是同时的,那么就会看到用wait可以消除多个僵尸进程的情况)
    ```
    ./server
    ./multiclient # 如果没有观察到的话,可以考虑把同时连接的套接字的个数再增加.
    #------------------------------------------------------------------
    # orris    16530  5904  0 21:32 pts/1    00:00:00 ./server
    # orris    16550 16530  0 21:32 pts/1    00:00:00 [server] <defunct>
    # orris    16551 16530  0 21:32 pts/1    00:00:00 [server] <defunct>
    #------------------------------------------------------------------

    ```
3. (方法3,推荐)捕捉到SIGCHLD信号后,轮询所有子进程,如果发现是退出状态,就调用waitpid执行,从而即使只收到1个SIGCHLD,也会遍历到要退出的子进程
```
void handle_sigchld(int sig)
{
    //循环调用waitpid去轮询子进程,如果检测到他们是退出状态,我们就释放该僵尸进程
    while(waitpid(-1,NULL,WNOHANG)>0);
}

int main()
{
    signal(SIGCHLD,handle_sigchld);
    //....
}
```


## 2. FIN_WAIT2重现
1. 服务端调用close,处于FIN_WAIT1状态
2. 客户端只要收到TCP请求后,都要返回ACK,所以服务端处于FIN_WAIT2状态
3. 观察客户端代码,客户端阻塞在fgets函数里,应用程序无法发出FIN请求=>服务端处于FIN_WAIT2状态
```
./server
./fin_wait_client
然后Ctrl+C消灭server后
netstat -nat | grep 5188
#--------------------------------------------------------------------------------------
# tcp        1      0 127.0.0.1:52270         127.0.0.1:5188          CLOSE_WAIT 
# tcp        0      0 127.0.0.1:5188          127.0.0.1:52270         FIN_WAIT2  
#--------------------------------------------------------------------------------------
```

## 3. SIGPIPE
1. SIGPIPE信号默认会关闭进程
```
./server
./sigpipe_client
Ctrl+C退出server端
在客户端输入123,发现没有输出"server close"就退出了=>2次调用write的时候,第一个write导致我们收到对方的RST的包,第二次调用write的话,就会产生SIGPIPE信号,该信号默认结束进程
但这里客户端中我们重新定义了处理函数,之所以程序还是会退出是因为read函数接收0而退出了
sigpipe信号忽略即可.(在client.c中我们忽略了sigpipe信号)
```


## 4. IO
### 4-1. select客户端解决CLOSE_WAIT和FIN_WAIT2状态
1. 问题:我们的程序会处于CLOSE_WAIT和FIN_WAIT2的状态是因为服务端关闭后,客户端停留在fgets函数上等待键盘输入.如果我们让客户端同时处理键盘输入和套接口缓冲区的话,那么就不会出现这种问题了
2. 解决
    1. 在客户端上用select管理标准输入和套接口缓冲区的IO,并进行处理
    2. 如果服务端关闭套接字,那么客户端的套接口缓冲区发生IO=>有数据库可读=>客户端马上处理=>客户端发送FIN给服务端,从而客户端处于CLOSED状态,服务端进入TIME_WAIT状态.(解决了上面出现CLOSE_WAIT和FIN_WATI2状态)
```
./server
./select_client

ps aux | grep sever# kill -9掉第二个./server进程(通常第二个是子进程)
#--------------------------------------------------------------------------------
# orris     4289  0.6  0.7 713776 60208 ?        Ssl  Aug26   2:57 /usr/lib/gnome-terminal/gnome-terminal-server
# orris    24687  0.0  0.0   4444   792 pts/1    S+   00:42   0:00 ./server
# orris    24689  0.0  0.0   4444    80 pts/1    S+   00:42   0:00 ./server
# orris    24691  0.0  0.0  14352   972 pts/0    S+   00:42   0:00 grep --color=auto server
#--------------------------------------------------------------------------------
kill -9 24689



netstat -nat | grep 5188
#--------------------------------------------------------------------------------
# tcp        0      0 0.0.0.0:5188            0.0.0.0:*               LISTEN     
# tcp        0      0 127.0.0.1:5188          127.0.0.1:53116         TIME_WAIT  
#--------------------------------------------------------------------------------
```
### 4-2. 单进程select服务器
1. 服务器维护监听套接字和连接套接字IO的列表
2. select获取有可读的IO
3. 如果是监听套接字=>有新的连接套接字要处理
4. 如果是连接套接字=>有数据要处理
```
./select_server
./client
./client
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# 自由输入就可以了
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

```
