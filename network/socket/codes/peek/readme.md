    
## 1. MSG_PEEK
```
封装recv函数,指定使用MSG_PEEK标志
开始循环:获取套接口缓冲区里的数据,使用recv函数
    如果是中断的情况,就继续循环
    返回结果


readline实现:接收套接口缓冲区的数据时,使用\n判断结尾=>解决粘包问题
1. 注意
    1. 使用recv实现,所以解决的是读取套接口缓冲区数据的情景
    2. fgets函数保留\n
2. 实现
定义数据缓冲区
定义剩余字节长度
开始循环:peek获取套接口缓冲区里的数据缓冲区中
    错误处理:
        如果返回<0的话,说明异常=>退出进程
        如果返回=0的话,说明对方关闭套接字=>退出函数,也返回0
    判断接收到的缓冲区里是否有\n
        遍历缓冲区的每个字节,长度为读取到的字节长度
        如果有\n的话
            用read函数读走套接口缓冲区(长度一直到\n为止,包括\n,因为下标有值所以知道长度)
            错误处理
                如果read函数的返回值没有达到指定长度的话,说明有问题=>退出进程
            结束循环
        如果没有\n的话
            更新剩余字节长度
            错误处理
                如果剩余字节长度<0,说明超出最大字节范围=>异常退出进程
            就先读出目前字节长度到数据缓冲区的指针里
            移动数据缓冲区的指针
返回读取的字节长度(最大字节长度-剩余字节长度)
```
