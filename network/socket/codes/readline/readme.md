## 1. 读取一行实现
1. 获取套接口缓冲区里的数据(不清除缓冲区)
2. 检查数据是否含有`\n`.
    1. 如果有=>清除缓冲区里的数据直到`\n`,结束函数并返回读取了的字节长度<=对方发送的数据必须刚好到`\n`为止,否则后面的recv不会堵塞
    2. 如果没有=>清除已经读取的数据,移动缓冲区指针到下一个,继续循环
3. 如果运行到这里,说明出现异常=>异常退出进程
```
ssize_t readline(int sockfd, void *buf, size_t maxlen)
{
    定义剩余字节长度
    定义数据缓冲区的指针
    开始循环:peek获取套接口缓冲区里的数据缓冲区中
        错误处理:
            如果返回<0的话,说明异常=>退出进程
            如果返回=0的话,说明对方关闭套接字=>退出函数,也返回0
        判断接收到的缓冲区里是否有\n
        遍历缓冲区的每个字节,长度为读取到的字节长度
            如果有\n的话
                用readn函数读走套接口缓冲区(长度一直到\n为止,包括\n,因为下标有值所以知道长度)
                错误处理
                如果read函数的返回值没有达到指定长度的话,说明有问题=>退出进程
                退出函数
        如果没有\n的话
            更新剩余字节长度
            错误处理
            如果剩余字节长度<0,说明超出最大字节范围=>异常退出进程
            就先读出目前字节长度到数据缓冲区的指针里
            移动数据缓冲区的指针
    返回读取的字节长度(最大字节长度-剩余字节长度)
}
```
