## 1. Makefile
[makefile笔记](https://github.com/orris27/orris/blob/master/cpp/makefile.md).因为github会用tabs8,所以这里把他们换到其他地方了

## 2. 进程
### 2-1. 函数
1. 创建子进程
```
pid_t pid;
pid = fork();
if (pid == 0)
{
    // 子进程处理内容
    exit(EXIT_SUCCESS);
}
else
{
    // 主进程处理内容
}
```

## 3. 库
### 3-1. 静态库
#### 3-1-1. 制作
1. 生成.o文件
2. 打包.o文件
3. 编译时指定静态库
```
tree
#------------------------------------------------------------------------------
# .
# ├── include
# │   └── calc.h
# ├── lib
# ├── main.c
# └── src
#     ├── add.c
#     └── minus.c
#------------------------------------------------------------------------------

vim include/calc.h
###################################################################################
#ifndef _CALC_H_
#define _CALC_H_
int add(int a,int b);
int minus(int a,int b);
#endif
###################################################################################


vim src/add.c
###################################################################################
#include "calc.h"

int add(int a,int b)
{
    return a+b;
}
###################################################################################


vim src/minus.c 
###################################################################################
#include "calc.h"

int minus(int a,int b)
{
    return a-b;
}
###################################################################################

vim main.c 
###################################################################################
#include <stdio.h>
#include "calc.h"

int main()
{
    int a = 1;
    int b = 2;
    printf("%d\n",add(a,b));
    return 0;
}
###################################################################################





cd src/
gcc *.c -c -I ../include
ar rcs libmycalc.a *.o # 
mv libmycalc.a ../lib
cd ..
gcc main.c lib/libmycalc.a -o main -I ./include
#gcc main.c -I ./include -L lib -l mycalc -o main 
./main
```


### 3-2. 动态库
#### 3-2-1. 制作
1. 生成位置无关的.o文件
2. 打包.o文件
3. 编译时指定动态库
```

tree
#------------------------------------------------------------------------------
# .
# ├── include
# │   └── calc.h
# ├── lib
# ├── main.c
# └── src
#     ├── add.c
#     └── minus.c
#------------------------------------------------------------------------------

cd src/
gcc -fPIC -c *.c -I ../include
gcc -shared -o libmycalc.so *.o
mv libmycalc.so ../lib/
cd ..
gcc main.c lib/libmycalc.so -o main -I ../include
#gcc main.c -I ./include -L lib -l mycalc -o main 

./main
#---------------------------------------------------------------------
# ./main: error while loading shared libraries: libmycalc.so: cannot open shared object file: No such file or directory
#---------------------------------------------------------------------

ldd main
#---------------------------------------------------------------------
# 	linux-vdso.so.1 =>  (0x00007ffff1161000)
# 	libmycalc.so => not found # 自己的库没有找到
# 	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fdca53b7000) # 标准c库
# 	/lib64/ld-linux-x86-64.so.2 (0x00007fdca5999000)
#---------------------------------------------------------------------



##########################################################################################
# 方法1:使用系统动态库路径
##########################################################################################

sudo cp lib/libmycalc.so /lib
./main
#---------------------------------------------------------------------
# 3
#---------------------------------------------------------------------
sudo rm -f /lib/libmycalc.so



##########################################################################################
# 方法2:临时/永久自定义动态库路径(修改环境变量)
##########################################################################################
export LD_LIBRARY_PATH=./lib/ # 如果添加到/etc/profile等文件中就能永久生效了
ldd main
#---------------------------------------------------------------------
#	linux-vdso.so.1 =>  (0x00007ffe09b29000)
#	libmycalc.so => ./lib/libmycalc.so (0x00007fae750a9000)
#	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fae74cc9000)
#	/lib64/ld-linux-x86-64.so.2 (0x00007fae754ad000)
#---------------------------------------------------------------------
./main 
#---------------------------------------------------------------------
# 3
#---------------------------------------------------------------------



##########################################################################################
# 方法3:永久自定义动态库路径(修改配置文件)
##########################################################################################
sudo vim /etc/ld.so.conf
########################################################################################
/home/orris/fun/c/test/lib
#########################################################################################

sudo ldconfig -v # 使配置文件生效
./main 
#---------------------------------------------------------------------
# 3
#---------------------------------------------------------------------

```

## 4. UNIX编程
vim下光标放在函数上,用`shift + k`可以跳到对应man文档.按`q`退出
### 4-1. 接口
1. 文件的属性
    1. stat,fstat,lstat:获取属性信息.基本等同于命令行中`stat`命令
        1. stat:不用打开文件也能读文件属性
        2. fstat:需要打开文件才能读文件属性
        3. lstat:不追踪软连接文件.读软连接文件时会只读出软连接文件本身的属性,比如lstat读软连接文件后大小是29字节.其他函数都是读取软连接出去的文件的大小
    2. access:查看文件是否可读,可写,可执行等
    3. chmod,fchmod:修改文件权限
    4. fcntl: f control  
        1. 复制文件描述符.(=dup/dup2)
        2. 获取/修改变已经打开的文件的选项
            1. 使用
                1. `int flag = fcntl(fd,F_GETFL,0);`:获得文件的打开选项
                2. `fcntl(fd,F_SETFL,flag|O_APPEND或者O_NONBLOCK);`
            2. 比如说我以只读方式打开文件后,需要执行追加操作,那么就添加O_APPEND的选项.
            3. 只能设置追加/非阻塞2种模式.只读后再加追加是没有用的.
2. truncate:截取文件长度
    1. 第二个参数表示从该参数位置开始后面的内容都被删除掉
    2. 清空的话,第二个值写0就行了
3. 链接相关
    1. link:创建硬链接
    2. symlink:创建软连接
    3. readlink:读取软连接文件本身的内容(实际上就是链接的内容)
    4. unlink:减少硬链接数,如果减少到0就会删除文件
        1. 实现临时文件的原理:打开1个文件后直接unlink,这样等关闭文件后就会自动删除该文件
4. rename(C库函数)
5. 目录
    1. chdir:修改进程所在的目录.进程默认都是在当前目录下的.
    2. getcwd:获取进程所在的目录
    3. mkdir
    4. rmdir:删除1个空目录
    5. opendir:打开1个目录,必须之后关闭1个目录.返回的是`DIR*`指针,其实类似fopen返回`FILE*`
    6. readdir:读目录.返回`struct dirent*`.指定while循环会自动遍历
    7. closedir:关闭1个目录
6. 文件描述符
    1. dup:复制文件描述符为最小的文件描述符
    2. dup2:(dup to)复制文件描述符为指定的文件描述符
        1. 如果指定的文件描述符已经被打开了,就先关闭再重定向到要复制的文件描述符
        2. 如果指定的文件描述符=要复制的文件描述符,就什么也不做
        3. 可以重定向stdout
        4. dup2(2,3)表示把2拷贝到3,从而3也指向了stderr
            + 重定向stdout:`dup2(3,1或者STDOUT_FILENO)`
    3. 注意:复制文件描述符后,他们都会共同偏移!即先write给fd,再write给fd_copy,后者会在前者后面
7. 环境变量
    1. `extern char** environ;`environ以NULL作为哨兵结尾
        + 保存的格式是"环境变量名=值"
    2. getenv:获得环境变量
    3. setenv:设置环境变量.第三个参数表示是否覆盖原来的环境变量
    4. unsetenv:删除环境变量
8. 用户id
    1. getuid:获得当前终端的用户
    2. geteuid:获得有效用户.比如orris用sudo命令后,`getuid`返回orris,而`geteuid`返回root
    3. getgid
    4. geteuid

9. exec函数族
    1. `man exec<按tab>`
        1. execl:list.
        2. execlp:list path.要用PATH的变量
            1. 参数:文件名,`argv[0]`,`argv[1]`,`argv[2]`,...,NULL
            2. `argv[0]`最好和文件名相同
            3. 老师在execlp中使用`ls`,在execl中使用`/bin/ls`是因为`ls`本身就是可执行程序.所以文件名中写命令也是正确的,毕竟命令名就是文件名.
        3. execle:list environ.要借助环境变量表
        4. execv:list argv[].需要自己构件命令行参数数组
        5. execvp
        6. execve
    2. exec不会创建新的进程,所以前后pid相同.
    3. exec会改变进程的.text段,进程从新程序的启动例程(比如说main函数)开始执行
    4. 进程执行exec内的程序后就不会再执行exec下面的内容了
10. 回收子进程
    1. wait
        1. 原理
            1. 阻塞等待子进程退出
            2. 回收子进程的PCB
            3. 获取子进程的退出码
        2. status(传出参数)
            1. WIFEXITED(status):判断是否是正常退出(status>=0).如果为真就调用WEXITSTATUS(status),返回子进程退出的值
            2. WIFSIGNALED(status):判断是否是正常退出(status<0).如果为真就调用WTERMSIG(status),返回子进程异常退出的信号值
            3. 前者是进程的退出值,后者是收到的信号对应的信号编号(kill -l)
    2. waitpid
        1. 非阻塞式回收.父进程收到SIGCHLD信号后,循环调用非阻塞式的waitpid,这样waitpid就会一直回收完所有子进程.而回收完毕后就会NULL哨兵返回


11. 信号
    1. 原理
        1. 进程A发出信号,交给内核,内核再发给进程B,不管执行到哪里,进程B都要停下来,进程B进入就走到内核里,查看信号是否有捕捉函数等信息,如果有捕捉函数,就回到用户空间去处理信号,之后再回到原来的指令
            1. 产生=>(内核)
            2. 阻塞信号集(信号屏蔽字):存储格式和未决信号集一样.1表示屏蔽了,0表示没有屏蔽
                1. 如果阻塞信号集对应信号编号的值为1,即屏蔽了该信号,那么如果内核拿到该信号,就递达不给进程B了.此时未决信号集不能从1变为0
                2. 举例说明
                    1. `阻塞[5]<=1`,如果内核要给进程B 5号信号,发现5号信息被屏蔽了,就递达不了,`未决[5]`保持1不变
            3. 未决信号集:没有被处理掉的信号.存储类似于数组的东西,格式为`arr[信号编号]<=信号状态(0或1)`.
                1. 初始的时候,所有值都为0
                2. 产生信号9的时候,内核马上将`arr[9]`赋值1
                3. 内核拿到信号,递达给进程B,马上将`arr[9]`赋值0.=>由此可以0->1->0的过程是瞬时的
                4. 如果多个11号信号到来,由于未决信号集的机制,只处理1次
            4. sa_mask:捕捉函数执行期间使用的阻塞信号集
                
        2. 软中断:借助软件实现的中断.而CPU上下文切换的时钟中断是硬件实现的,和这个不同.
    2. 发出信号
        1. 按键
            1. Ctrl+C:2号(SIGINT)
            2. Ctrl+Z:20号(SIGTSTP)=>Stop暂停进程
            3. Ctrl+\:3号(SIGQUIT)
        2. 系统调用
            1. kill
                1. pid:=0:发送信号给当前进程相同进程组的所有进程.-1:发送信号给有权限发送的所有进程.<0:发送给进程组(kill命令也一样PGID)
                2. `cat | cat | cat | cat`:如果kill掉第一个cat,那么实际上所有cat都会死掉.这是因为管道的特性,后面的cat由于写端的管道不存在了,所以也就会被杀死.
            2. raise:给自己发送信号
            3. abort:给自己发送终止信号(SIGABRT)
        3. 软件条件
            1. 定时器
                1. alarm
                    1. 用途:指定多少秒后给自己发送SIGALRM信号,默认动作是退出(alarm(0)例外)
                    2. 注意:每个进程都有且只有一个定时器=>创建出子进程后定时器不共享
                    3. 返回值:上次调用定时器的剩余时间.第二次调用定时器会重新计时
                        1. 第一次调用5s,2s过后调用定时器5s.返回值是3s(剩余5-2=3s),再过5s发信号
                    4. alarm(0):停止计时
                    5. 自然计时,不管进程处于什么状态
                2. setitimer
                    1. 精度高于alarm的定时器
                    2. 参数
                        1. which:计时从什么阶段开始.
                            1. ITIMER_REAL:自然计时
                            2. ITIMER_VIRTUAL:用户空间才计时
                            3. ITIMER_PROF:用户空间+内核空间才计时(进程执行时间=系统时间+用户时间+等待时间)
                        2. new_value
                            1. struct itimerval结构
                                1. it_interval:下一次定时的值(周期定时)
                                    1. 先经过it_value秒发送信号,之后每经过it_interval时间发送信号
                                2. it_value:当前的值
                                3. struct timeval结构
                                    1. tv_sec:
                                    2. tv_usec:微秒定时
                            2. 构造setitimer的参数
                                1. `it.it_value.tv_sec` = ;
                                2. `it.it_value.tv_usec` = ;
                                3. `it.it_interval.tv_sec` = ;
                                4. `it.it_interval.tv_usec` = ;
                        3. old_value:(传出参数):上次定时剩余的.
        4. 硬件异常产生:如段错误
        5. 命令产生
    
    3. 处理信号
        1. 执行默认动作
            1. Term:终止进程
            2. Ign:丢弃信号
            3. Core:终止进程,生成core文件(记录进程的退出信息,方便gdb调试)
            4. Stop:暂停进程
            5. Cont:继续运行暂停的进程
        2. 丢弃信号:未决信号集会从1置0,只是处理动作是丢弃而已
        3. 调用用户处理函数
            1. signal:注册信号的处理函数.(内核捕捉信号,内核会帮我们调用这个用户处理函数)
            2. sigaction:注册信号的处理函数,并输出旧的处理函数
                1. struct sigaction
                    1. sa_mask:设置信号捕捉函数处理过程时屏蔽的信号
                    2. sa_flags:使用0表示默认属性:信号捕捉函数处理期间自动屏蔽本信号
    4. 处理信号集
        1. 集合:`sigset_t set`:本质是unsigned long.实际作用类似于数组,第n位表示第n个信号
        2. `int sigemptyset(sigset_t *set);`清空.将某个信号集清0
        3. `int sigfillset(sigset_t *set);`将某个信号集置1
        4. `int sigaddset(sigset_t *set, int signum);`添加某个信号到信号集(0=>1)
        5. `int sigdelset(sigset_t *set, int signum);`删除信号机中的某个信号(1=>0)
        6. `int sigismember(const sigset_t *set, int signum);`判断某个信号是否在信号集中
        7. `sigprocmask`:将我们的信号集放到系统的信号集
            1. how:设置阻塞还是非阻塞.
                1. SIG_BLOCK:只处理为1的信号.如果我们的信号集中3号信号是1,那么阻塞信号集的3号信号会被屏蔽,变成1
                2. SIG_UNBLOCK:只处理为1的信号.如果我们的信号集中3号信号是1,那么阻塞信号集的3号信号会取消被屏蔽,变成0
                3. SIG_SETMASK:我们的信号集完全覆盖阻塞信号集
            2. set:我们的信号集
            3. oldset:(传出参数)设置前的阻塞信号集情况
        8. `sigpending`:读取当前进程的未决信号集
    5. 信号表:查看后面内容
    6. 特殊:
        1. 9号(SIGKILL)信号和19号(SIGSTOP)信号不允许忽略和捕捉=>只能且必须执行默认动作
        2. SIGTSTP停止终端交互进程的执行,和SIGSTOP则是暂停进程
    7. 注意:
        1. 如果我们在sleep期间收到信号,那么处理信号结束后,就继续执行后面的内容了,而不再睡了

12. 时序竞态
    1. sigsuspend:在函数调用期间,阻塞信号集由参数决定,而不是由PCB的阻塞信号集决定.
        1. 作用:时序竞态中sigsuspend捆绑了解除SIGALRM屏蔽和挂起等待信号2个动作.它是系统调用,所以一定是原子操作.
        2. 原理:
            1. 屏蔽SIGALRM信号
            2. 开始计时
            3. 如果此时没有获取到CPU时间片,那么SIGALRM信号已经到达,并且放在未决信号集里面
            4. 解除SIGALRM信号并挂起.此时发现SIGALRM信号在未决信号里,就会处理SIGALRM信号了

#### 4-1-1. 文件
1. 特点
    1. `mode_t mode`:文件的权限.是个八进制的数,实际文件的权限是mode和umask共同处理的结果.详见[Linux权限文档](https://coggle.it/diagram/WzNw5TCAbhFNoY8H/t/linux%E8%A7%92%E8%89%B2)
    2. `int flags`:打开/创建文件的选项.就是O_RDWR,O_CREATE这些.
        1. `O_CREAT|O_EXEL`:查看文件是否存在
        2. `O_TRUNC`:清空文件
    3. `ssize_t`:有符号的`size_t`
    4. `f`开头的函数:一般都是要用文件描述符作为参数,如`fstat`比较于`stat`
2. 属性
    1. `struct stat`中的`st_mode`:保存文件类型(普通文件,目录,块设备,符号连接等)和权限


### 4-2. 结构体
1. 读目录
```
struct dirent {
    ino_t          d_ino;       // 此目录进入点的inode
    off_t          d_off;       // 目录文件开头至此目录进入点的位移
    unsigned short d_reclen;    // d_name的长度,不包含NULL字符
    unsigned char  d_type;      // d_name所指的文件类型(块设备,字符设备,目录DT_DIR,普通文件DT_REG)
    char           d_name[256]; // 文件名
};

```
### 4-3. 错误
1. 我们写的`#include <errno.h>`的文件在`/usr/include/errno.h`里面
    1. `/usr/include/errno.h`里面申明了`extern int errno`,说明errno是个全局变量
2. errno的定义及描述:`/usr/include/asm-generic/errno.h` `/usr/include/asm-generic/errno-base.h`
3. `perror(m)`中的m是用户自定义描述,然后再返回具体的描述


### 4-4. 进程共享
[Process笔记](https://github.com/orris27/orris/blob/master/process/process.md)

### 4-5. 信号表
1) SIGHUP: 当用户退出shell时，由该shell启动的所有进程将收到这个信号，默认动作为终止进程
2) SIGINT：当用户按下了<Ctrl+C>组合键时，用户终端向正在运行中的由该终端启动的程序发出此信号。默认动
作为终止进程。
3) SIGQUIT：当用户按下<ctrl+\>组合键时产生该信号，用户终端向正在运行中的由该终端启动的程序发出些信
号。默认动作为终止进程。
4) SIGILL：CPU检测到某进程执行了非法指令。默认动作为终止进程并产生core文件
5) SIGTRAP：该信号由断点指令或其他 trap指令产生。默认动作为终止里程 并产生core文件。
6) SIGABRT: 调用abort函数时产生该信号。默认动作为终止进程并产生core文件。
7) SIGBUS：非法访问内存地址，包括内存对齐出错，默认动作为终止进程并产生core文件。
8) SIGFPE：在发生致命的运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等所有的算法错误。默认动作为终止进程并产生core文件。
9) SIGKILL：无条件终止进程。本信号不能被忽略，处理和阻塞。默认动作为终止进程。它向系统管理员提供了可以杀死任何进程的方法。
10) SIGUSE1：用户定义 的信号。即程序员可以在程序中定义并使用该信号。默认动作为终止进程。
11) SIGSEGV：指示进程进行了无效内存访问。默认动作为终止进程并产生core文件。
12) SIGUSR2：另外一个用户自定义信号，程序员可以在程序中定义并使用该信号。默认动作为终止进程。
13) SIGPIPE：Broken pipe向一个没有读端的管道写数据。默认动作为终止进程。
14) SIGALRM: 定时器超时，超时的时间 由系统调用alarm设置。默认动作为终止进程。
15) SIGTERM：程序结束信号，与SIGKILL不同的是，该信号可以被阻塞和终止。通常用来要示程序正常退出。执行shell命令Kill时，缺省产生这个信号。默认动作为终止进程。
16) SIGSTKFLT：Linux早期版本出现的信号，现仍保留向后兼容。默认动作为终止进程。
17) SIGCHLD：子进程结束时，父进程会收到这个信号。默认动作为忽略这个信号。
18) SIGCONT：如果进程已停止，则使其继续运行。默认动作为继续/忽略。
19) SIGSTOP：停止进程的执行。信号不能被忽略，处理和阻塞。默认动作为暂停进程。
20) SIGTSTP：停止终端交互进程的运行。按下<ctrl+z>组合键时发出这个信号。默认动作为暂停进程。
21) SIGTTIN：后台进程读终端控制台。默认动作为暂停进程。
22) SIGTTOU: 该信号类似于SIGTTIN，在后台进程要向终端输出数据时发生。默认动作为暂停进程。
23) SIGURG：套接字上有紧急数据时，向当前正在运行的进程发出些信号，报告有紧急数据到达。如网络带外数据到达，默认动作为忽略该信号。
24) SIGXCPU：进程执行时间超过了分配给该进程的CPU时间 ，系统产生该信号并发送给该进程。默认动作为终止进程。
25) SIGXFSZ：超过文件的最大长度设置。默认动作为终止进程。
26) SIGVTALRM：虚拟时钟超时时产生该信号。类似于SIGALRM，但是该信号只计算该进程占用CPU的使用时间。默认动作为终止进程。
27) SGIPROF：类似于SIGVTALRM，它不公包括该进程占用CPU时间还包括执行系统调用时间。默认动作为终止进程。
28) SIGWINCH：窗口变化大小时发出。默认动作为忽略该信号。
29) SIGIO：此信号向进程指示发出了一个异步IO事件。默认动作为忽略。
30) SIGPWR：关机。默认动作为终止进程。
31) SIGSYS：无效的系统调用。默认动作为终止进程并产生core文件。
34) SIGRTMIN ～ (64) SIGRTMAX：LINUX的实时信号，它们没有固定的含义（可以由用户自定义）。所有的实时信号的默认动作都为终止进程。

## 5. UNIX网络编程
1. [coggle笔记](https://coggle.it/diagram/W33p6eGhIvMJaYJJ/t/socket)
2. [socket笔记](https://github.com/orris27/orris/blob/master/network/socket/socket.md)
3. [socket接口笔记](https://github.com/orris27/orris/blob/master/network/socket/interface.md)
